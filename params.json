{"name":"Hibernate Search GenericJPA","tagline":"Hibernate-Search with the JPA provider you want","body":"Hibernate-Search-JPA\r\n====================\r\n[![Build Status](http://ci.hibernate.org/view/Personal%20runs/job/GSOC-hibernate-search-jpa/badge/icon)](http://ci.hibernate.org/view/Personal%20runs/job/GSOC-hibernate-search-jpa/)\r\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/Hotware/Hibernate-Search-JPA?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nHibernate-Search with the JPA provider you want.\r\n\r\nCurrently supported JPA providers:\r\n\r\n* Hibernate\r\n* EclipseLink\r\n* OpenJPA\r\n\r\nCurrently supported Databases (others work as well, but don't have automatic updating support):\r\n\r\n* MySQL/MariaDB\r\n* PostgreSQL\r\n\r\nhttp://hibernatesearchandjpa.blogspot.de/\r\n\r\nIntroduction\r\n============\r\nHibernate Search is an awesome library if you have a JPA based application and want to add fully fletched fulltext search capabilities to your domain model. You simply add annotations to the fields you want to index and then you can generate a working Index from the JPA objects. When the database changes, the index is updated accordingly. This works just fine (TM).\r\n\r\nHere is an example from the [Hibernate Search getting started page](http://hibernate.org/search/documentation/getting-started/)\r\n\r\n    @Entity\r\n    @Indexed\r\n    public class Book {\r\n    \r\n      @Id\r\n      @GeneratedValue\r\n      private Integer id;\r\n    \r\n      @Field(index=Index.YES, analyze=Analyze.YES, store=Store.NO)\r\n      private String title;\r\n    \r\n      @Field(index=Index.YES, analyze=Analyze.YES, store=Store.NO)\r\n      private String subtitle;\r\n    \r\n      @Field(index=Index.YES, analyze=Analyze.NO, store=Store.YES)\r\n      @DateBridge(resolution=Resolution.DAY)\r\n      private Date publicationDate;\r\n    \r\n      @IndexedEmbedded\r\n      @ManyToMany\r\n      private Set<Author> authors = new HashSet<Author>();\r\n      public Book() {\r\n      }\r\n    \r\n      // standard getters/setters follow here\r\n      ...\r\n    }\r\n    \r\nOne of the few problems it has, is that once you decide to use Hibernate Search you have to use/stick with Hibernate ORM and lose the possibility to swap the JPA provider for something along the lines of EclipseLink (switching the JPA provider - in my eyes - is one of the big benefits of using JPA), i.e. because your (new) Jave EE Container ships with it and you don't want to change it. This is due to Hibernate Search relying on Hibernate ORM specific events to update its index. These are by far more sophisticated than the ones plain JPA provides and while other JPA providers might have similar features, there is no clear specification for these.\r\n\r\n![The current problem](http://4.bp.blogspot.com/-AMJtBIXzeSQ/VUCdkYUCMGI/AAAAAAAAALc/S8OVX9esVOQ/s1600/Hibernate-Search-With-Any-Problem-Schema.png)\r\n\r\nThe goal of Hibernate-Search-JPA is to fix this and provide an integration of Hibernate Search's Engine that works with (most) JPA providers (and for now only SQL databases):\r\n\r\n![What we aim for](http://1.bp.blogspot.com/-U0osGoQE0DI/VUCemKbVoJI/AAAAAAAAALk/f1vt4Fln2ko/s1600/Basic%2BDesign%2B(1).png)\r\n\r\nExamples\r\n========\r\n\r\nAn example on how to use this project can be found in the wiki: \r\nhttps://github.com/Hotware/Hibernate-Search-JPA/wiki/How-To","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}